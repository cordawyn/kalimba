require "securerandom"

# TODO: make it possible to choose a backend
# (e.g., Redland, RDF.rb, others)
require "kalimba/persistence/redlander"

module Kalimba
  # @abstract
  #   Backend implementations should override all methods
  #   that delegate processing to their parent class (invoking "super").
  module Persistence
    # TODO: make it possible to choose a backend
    # (e.g., Redland, RDF.rb, others)
    include Kalimba::Persistence::Redlander

    module ClassMethods
      # TODO: make it possible to choose a backend
      # (e.g., Redland, RDF.rb, others)
      include Kalimba::Persistence::Redlander::ClassMethods

      # Create an instance of the backend storage (repository)
      #
      # @param [Hash] options backend storage options
      # @return [Any] instance of the backend storage
      def create_repository(options = {})
        super
      end

      # Create a new instance of RDFS class
      #
      # @param [Hash<Symbol, String> => Any] attributes
      # @return [Resource, nil]
      def create(attributes = {})
        super
      end

      # Check whether instances of the RDFS class exist in the repository
      #
      # @param [Hash<[Symbol, String] => Any>] attributes
      # @return [Boolean]
      def exist?(attributes = {})
        super
      end

      # Remove all instances of the RDFSClass from the repository
      #
      # @return [Boolean]
      def destroy_all
        super
      end

      def find(scope, options = {})
        case scope
        when :first
          find_each(options).first
        when :all
          find_each(options)
        else
          find(:first, :conditions => {:id => scope})
        end
      end

      def find_each(options = {})
        super
      end
    end

    def id
      subject && subject.fragment
    end

    # Check whether the model has never been persisted
    #
    # @return [Boolean]
    def new_record?
      super
    end

    # Check whether the model has ever been persisted
    #
    # @return [Boolean]
    def persisted?
      super
    end

    # Check whether the model has been destroyed
    # (remove from the storage)
    #
    # @return [Boolean]
    def destroyed?
      @destroyed
    end

    # Retrieve model attributes from the backend storage
    #
    # @return [self]
    def reload
      super
      self
    end

    # Remove the resource from the backend storage
    #
    # @return [Boolean]
    def destroy
      if !destroyed? && persisted? && super
        @destroyed = true
        freeze
      else
        false
      end
    end

    # Assign attributes from the given hash and persist the model
    #
    # @param [Hash<[Symbol, String] => Any>] params
    # @return [Boolean]
    def update_attributes(params = {})
      assign_attributes(params)
      save
    end

    # Persist the model into the backend storage
    #
    # @raise [KalimbaError] if fails to obtain the subject for a new record
    # @return [Boolean]
    def save(options = {})
      @subject ||= generate_subject
      if super
        @previously_changed = changes
        @changed_attributes.clear
        true
      else
        false
      end
    end

    private

    # Overridden implementation should return URI for the subject, generated by
    # using specific random/default/sequential URI generation capabilities.
    # Otherwise it should return nil.
    #
    # @raise [Kalimba::KalimbaError] if cannot generate subject URI
    # @return [URI, nil]
    def generate_subject
      super ||
        if self.class.base_uri
          self.class.base_uri.fragment = SecureRandom.urlsafe_base64
          self.class.base_uri
        else
          raise Kalimba::KalimbaError, "Cannot generate subject without base URI for #{self.class}"
        end
    end
  end
end
